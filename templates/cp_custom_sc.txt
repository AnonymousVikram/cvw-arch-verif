    // Custom coverpoints for Store Conditional

    cp_prev_lr : coverpoint (ins.prev.inst_name == "lr.w" | ins.prev.inst_name == "lr.d") {
        // previous instruction was load reserved
    }
    cp_prev_sc : coverpoint (ins.prev.inst_name == "sc.w" | ins.prev.inst_name == "sc.d") {
        // previous instruction was store conditional
    }
    // 
    cp_prev_store : coverpoint (ins.prev.insn[14:12]) iff (ins.prev.insn[6:0] == 7'b0100011) {
        // previous instruction was a store
        bins sb = {3'b000};
        bins sh = {3'b001};
        bins sw = {3'b010};
        `ifdef XLEN64
            bins sd = {3'b011};
        `else
            ignore_bins b3 = {3'b011};
        `endif
        wildcard ignore_bins badbin = {3'b1??};
    }
    cp_sc_fail : coverpoint (ins.current.rd_val) {
        bins fail = {0};
        bins pass = {1};
    }
    cp_cur_address : coverpoint (ins.current.rs1_val[6:3]) {
        
    }
    cp_prev_address : coverpoint (ins.prev.rs1_val[6:3] & ins.prev.rs1_val[31:7] == ins.current.rs1_val[31:7]) {
        
    }
    cp_prev_address_match : coverpoint (ins.prev.rs1_val + ins.prev.imm == ins.current.rs1_val) {

    }
    cp_custom_aqrl : coverpoint ins.current.insn[26:25]  iff (ins.trap == 0 )  {
        // Combinations of acquire and release
        ignore_bins aq_norl = {2'b10};
    }
    cp_custom_scd_lrsc : cross cp_prev_lr, cp_sc_fail;
    cp_custom_sc_addresses : cross cp_prev_sc, cp_cur_address, cp_prev_address;
    cp_custom_sc_after_store : cross cp_prev_store, cp_prev_address_match;
